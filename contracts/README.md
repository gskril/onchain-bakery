# Contracts

There are two primary smart contracts in this project:

- [Bread.sol](src/Bread.sol) - ERC1155 contract with inventory management that acts as an ordering system.
- [ProofOfBread.sol](src/ProofOfBread.sol) - ERC1155 contract for celebratory NFTs when customers pickup their bread.

## Bread.sol

How it's expected to work:

- There are three roles with the following purposes:
  - `DEFAULT_ADMIN_ROLE` updates the accounts that have the following roles.
  - `ADMIN_ROLE` is for high level admin tasks like withdrawing funds and upating metadata.
  - `SIGNER_ROLE` is for signing messages and lower level admin functions that can be called programmatically. One example of a future use case where this migth come in handy: allow an external contract add credit to a customer's account.
- Owner controls the inventory, which is a mapping of `tokenId` to `quantity`.
- When `quantity` is positive, the respective ERC1155 token is available for purchase.
- To place an order, the customer needs a signed message from our admin server. This allow us to arbitrarily allow or deny orders.
- If the admin server approves an order, a `claimId` is issued which has the following traits:
  - Can be used once.
  - Must be used by the requesting account.
  - Must be used before the expiration time.
- There is a credit system that allows an admin to give customers a discount. If a customer accidentally overpays for an order, a credit is issued to their account.
- The owner is able to revoke tokens, esentially canceling an order.

See [Bread.test.ts](test/Bread.test.ts) for a set of tests that aim to verify the above description.

## ProofOfBread.sol

How it's expected to work:

- A signature is required to mint a token. The signature will be generated by the admin server and have the same properties as the `claimId` in `Bread.sol`.
- The signed `claimId` in this case will be generated when the user scans a QR code during pickup.
- `collectBread()` is payable so that customers can add a tip during pickup if they want.
- It's not inherintly tied to `Bread.sol` to remain flexible. For example, if I want to allow +1's to collect a ProofOfBread NFT during pickup vs strictly accounts that own a receipt NFT from `Bread.sol`, I can do that.

## Local Development

From the parent monorepo directory, install dependencies.

```bash
pnpm install
```

Navigate to the contracts directory and create a `.env` file. You don't have to change any of the values for testing purposes.

```bash
cd contracts
cp .env.example .env
```

Compile contracts and run the tests.

```bash
pnpm test
```
